package scm.configuration;

import com.google.code.ssm.Cache;
import com.google.code.ssm.CacheFactory;
import com.google.code.ssm.api.format.SerializationType;
import com.google.code.ssm.config.DefaultAddressProvider;
import com.google.code.ssm.mapper.JsonObjectMapper;
import com.google.code.ssm.providers.CacheConfiguration;
import com.google.code.ssm.providers.xmemcached.MemcacheClientFactoryImpl;
import com.google.code.ssm.spring.SSMCache;
import com.google.code.ssm.spring.SSMCacheManager;
import com.google.code.ssm.transcoders.JsonTranscoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;
import java.util.stream.Collectors;

@Configuration
@EnableCaching
public class MemcachedConfiguration {
    public static final String KEY_DELIMETER = ":";

    private final Logger LOG = LoggerFactory.getLogger(MemcachedConfiguration.class);

    // extends AbstractSSMConfiguration
    @Value("${memcached.host}")
    private String host;

    @Value("${memcached.port}")
    private int port;

    /**
     * An expiration time is specified in seconds. They can be set from 0, meaning "never expire", to 30 days (60*60*24*30).
     * Any time higher than 30 days is interpreted as a unix timestamp date.
     * Using `int` to match the implementation in memcached library while a `long` may be a better fit.
     */
    @Value("${memcached.expiration}")
    private int expiration;

    @Value("#{'${memcached.names}'.split(',')}")
    private List<String> names;

    private CacheFactory getCacheFactory(String name) {
        final CacheConfiguration conf = new CacheConfiguration();
        conf.setConsistentHashing(true);
        conf.setKeyPrefixSeparator(":");
        conf.setUseNameAsKeyPrefix(true);

        final CacheFactory cf = new CacheFactory();
        // unfortunately with named cache, we needed to make a copy of `CacheFactory` per `Cache`
        cf.setCacheName(name);
        cf.setCacheClientFactory(new MemcacheClientFactoryImpl());
        cf.setAddressProvider(new DefaultAddressProvider(host + ":" + port));
        cf.setConfiguration(conf);
        cf.setDefaultSerializationType(SerializationType.JSON);
        cf.setJsonTranscoder(new JsonTranscoder(new JsonObjectMapper()));
        return cf;
    }

    private SSMCache getCache(String name) throws Exception {
        Cache c;
        CacheFactory cf = getCacheFactory(name);
        try {
            // getCache is the getter generated by lombok: it does not create cache object.
            c = cf.getObject();
        } catch(Exception ex) {
            // fail booting when desired cache cannot be created
            LOG.error("\"unable to create cache\" host=\"{}\" port=\"{}\" name=\"{}\"", name, ex);
            throw ex;
        }
        return new SSMCache(c, expiration, true);
    }

    @Bean(name="cacheManager")
    CacheManager cacheManager() {
        SSMCacheManager manager = new SSMCacheManager();
        manager.setCaches(names.stream()
                .map(name -> {
                    try {
                        return getCache(name);
                    } catch (Exception ex) {
                        throw new BeanCreationException("cacheManager", "failed creating cache", ex);
                    }
                })
                .collect(Collectors.toList())
        );
        return manager;
    }
}
